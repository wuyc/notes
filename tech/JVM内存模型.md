## Java内存结构
![](https://user-images.githubusercontent.com/40560751/77064513-92a1e980-6a1a-11ea-9789-ff4b1c5f5004.png)
### 线程共享
- **方法区：** 也称**非堆区**、~~**永久代**~~（在 Java8 中，永久代已经被移除，被一个称为“元空间”(Metaspace)的区域所取代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存。**）。**方法区存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**
- **堆：** Java 虚拟机所管理的内存中最大的一块，**几乎所有的对象实例都在这里分配内存。** 堆是垃圾回收器主要管理的区域。Java 堆中还可以细分为：**新生代**、**老年代**，再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。

### 线程私有
- **Java虚拟机栈：** **描述 Java 方法执行的内存模型。** 每个方法执行的时候都会创建一个栈帧，方法执行完毕后栈帧就会出栈，栈帧内存储了局部变量表、操作数栈等信息。局部变量表存储了 Java 的基本数据类型和引用变量，这是我们初学 Java 接触过的。
- **本地方法栈：** Java 虚拟机执行 Native 方法 (C/C++实现的方法) 的服务。
- **程序计数器：** **当前线程所执行的字节码的行号指示器。** 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址； **如果正在执行的是 Native 方法，这个计数器值则为空(Undefined)。**

## Java内存模型
&emsp;&emsp;Java 线程之间的通信由 Java 内存模型（Java Memory Model）控制。JMM 是 JVM 的一种规范，定义了 JVM 的内存模型。JMM 的目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器对代码指令重排序、处理器对代码乱序执行等问题。
&emsp;&emsp;JMM 定义了线程与主内存之间的抽象关系：线程之间共享的变量存在主内存中，每个线程都有一个工作内存。线程不直接操作主内存中的数据，而是拷贝一份主内存中的数据到工作内存，线程在工作内存中操作，操作完成后刷新到主内存中。
&emsp;&emsp;这种线程对内存的操作方式会导致数据对其它线程不可见，例如线程A拷贝了一份主内存中的数据操作完成后还没刷新到主内存中，然后线程B开始向主内存中获取数据，这时线程B获取的数据不是最新的，所以为了保证数据的可见性，Java 可以使用 volatile 修饰变量，对 volatile 修饰过的变量操作不会把拷贝一份到工作内存，而是直接在主内存中操作。volatile 保证了 Java 并发三大特性中的可见性和有序性，但不保证原子性。
![](https://user-images.githubusercontent.com/40560751/77064594-b8c78980-6a1a-11ea-839e-7030ebd27d80.png)

## 推荐阅读
- https://yq.aliyun.com/articles/651049
- https://www.cnblogs.com/ityouknow/p/5610232.html
- http://www.jiangxinlingdu.com/concurrent/2019/02/16/java-memory-model.html
- https://fitzeng.org/2017/09/02/reJVM/